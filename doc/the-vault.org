#+TITLE: Vault backup storage
* Design

** Storage structure

   Backup repository to record metadata and submodules for each unit
   to record changes.

*** Large files

    There is a separate task how to store large files. While it is
    possible to tune xdelta and pack retrieval strategy, copies of
    huge files are still stored inside pack files so space is wasted
    when files are checked out (twice as much space is used). So,
    files with size bigger than some value should be stored in the
    separate storage to avoid packing of those files. There are
    different options how this files can be recorded:

    - symlink: it allows to browse backup storage and open files
      directly from it but it is impossible to store symlinks on
      filesystems w/o symlink support (e.g. vfat) and to use
      e.g. FAT-formatted SD card as a backup storage. On the other
      hand unix permissions etc. are also not supported on those file
      systems.

    - file with the same name as original but prefixed by distinctive
      prefix and containig object hash recorded inside (and maybe some
      additional information). In this case it is possible to store
      data on e.g. vfat. In this case direct access (in-place) is not
      possible.

*** Using file systems incompliant with POSIX

    VFAT is the most interesting case because many SD cards are
    formatted with it. There are 2 issues:
    
    - file permission and ownership information is lost if files are
      copied to the incompliant file system
  
    - symlinks are not supported

    Basically it means if API allows executable backup units to just
    copy files into backup storage, files metadata will be lost. It is
    possible to find a compromise only if vault tools are used to copy
    files, so they can record metadata separetely. But it decreases
    flexibility. The second option is to provide fuse-based file
    system working as a bridge exposing POSIX-compliant FS and
    recording metadata transparently on the VFAT to the separate
    service files. It can be also helpful to manage large files by
    transparently splitting 'em.

**** Adapter file system storing metadata separately

     To solve issues with incompliant file systems it is possible to
     use adapter FS storing any metadata not supported by underlying
     FS in special files there. There is one such FS available, based
     on FUSE: [[http://sourceforge.net/projects/posixovl/][posixovl]]. This solution is very flexible and transparent
     while it also allows to avoid compromises.

** Backup model

   Possible implementation depends on backup model. 
   
*** Incremental backup

    Commit changes at the same branch in each unit.

**** Single unit branch, single root branch

    Record changes in each unit in the root repository commit in
    the master branch and tag it.

    Pros:

    - it is possible to optimize backup process

      If files are left in the tree backup script can analyse is
      anything changed update only changed files (e.g. if rsync is
      used for it)

    - it is clearly visible is unit data changed or not.
    
    Cons:

    - If some backup (commit) is deleted, tree need to be rebased ->
      commit ids will be changed -> need to update whole root branch
      too.

**** Single unit branch, multiply root branches

     Create branch in the root repo with single commit for each
     backup. Pros & Cons are the same as for the previous case but it
     becomes simplier to update root branch(es) in the case when
     backup is deleted: while each commit still should be updated
     because units hashes are changed there are no dependent
     changes between root repo commits.

*** Full backup

    Each backup is commited into separate branch.

    Pros:

    - backups are independent

      If one backup (commit) is deleted there is no need to rebase

    - objects are still shared and compressed in the same object
      storage

    Cons:

    - it is more complicated to optimize backup in the incremental way
      (while maybe still possible)

** Vault structure

   Vault consists of the *root repository* and any amount of *unit
   repositories*. Root repository manages metadata about available
   units and snapshots. Unit repository manages data related to some
   application/functionality etc. Repositories are managed by git. All
   vault-specific data is stored in the =.vault= subdirectory of the
   git tree.

#+BEGIN_SRC dot :file out/vault-structure.png :cmdline -Kdot -Tpng
  digraph Vault {
      rankdir=LR;
      Root;
      RootGit [label=".git"];
      RootVault [label=".vault"];
      Unit0 [label="Unit_0"];
      Unit0Git [label=".git"];
      Unit0Vault [label=".vault"];
      Root -> RootGit;
      Root -> RootVault;
      Root -> Unit0;
      Unit0 -> Unit0Git;
      Unit0 -> Unit0Vault;
  }
#+END_SRC

#+RESULTS:
[[file:out/vault-structure.png]]

*** Units

    Unit is stored as a separate git repository and reference to it is
    stored in the root repository. Unit data can be stored inside of
    the unit git tree as also outside of it.

    There are 2 types of units by the way how files are handled by git:

    - with separate blobs storage
      
    Separate storage allows to store blobs have size above some
    empirical limit in the separate storage located inside git
    reposotiry. Git manages only symlinks. This model is preferred for
    the data stored outside of the git tree to avoid multiply data
    copying. Also it increases the speed of git operations.

    - managing blobs fully by git

    This is suitable for units managing medium and small files as for
    units storing files inside the git tree. In this case git
    operations can be slower for large files. Also cloning pulls all
    the data to the remote repository - sometimes it can be redundant.

    Also units can provide hooks executed on different stages of
    backup/restore process.

*** Root repository

    Root repository 

*** Snapshots

    Snapshot is the mark pointing to the state of data in some moment
    of time. Snapshot in the root repository is created as a branch
    forked from the =master= branch, it allows snapshots to be
    independent on each other, so no rebase is needed if some snapshot
    is deleted. Unit refers to the snapshot by means of the tag with
    the name equal to the name of the snapshot. Snapshot name consists
    of 3 parts separated by slash: prefix =vault-shot=, unique =vault
    id= and =date/time= in ISO format modified to be valid git
    reference (allowed symbols).

** Actions

*** TODO Commit
    
*** Revert

    State is restored by means of full or partial snapshot
    reverting. This process consists of 2 steps:

    - checkout snapshot branch in the root repository

    - revert commits in the range between snashot and HEAD

    Data is reverted in each unit repository chosen for restoration.

